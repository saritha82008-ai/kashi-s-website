<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Platformer â€” Long Hard Level</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: sans-serif;
    }
    canvas {
      display: block;
    }
    #overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      color: white;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 3em;
      visibility: hidden;
      z-index: 2;
    }
    #hint {
      position: absolute;
      bottom: 16px; left: 16px;
      color: #fff;
      background: rgba(0,0,0,0.4);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 14px;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div id="overlay">YOU WIN!</div>
  <div id="hint">Arrows to move, Space to jump. Drag mouse to rotate. Reach the yellow goal.</div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0, 5, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x445566, 0.6);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(8, 12, 6);
    scene.add(dir);

    // Player
    const playerGeometry = new THREE.BoxGeometry(1,1,1);
    const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });
    const player = new THREE.Mesh(playerGeometry, playerMaterial);
    player.position.set(0, 1, 0);
    scene.add(player);

    // Platforms (long hard level layout)
    let platforms = [];
    function createPlatform(x,y,z,w=5,h=1,d=5,color=0x7a5230){
      const g = new THREE.BoxGeometry(w,h,d);
      const m = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(g,m);
      mesh.position.set(x,y,z);
      scene.add(mesh);
      platforms.push({ mesh, halfW:w/2, halfH:h/2, halfD:d/2 });
      return mesh;
    }
// Example: Moving platform logic
function createMovingPlatform(x, y, z, w, h, d, color, axis, range, speed) {
    const platform = createPlatform(x, y, z, w, h, d, color);

    let direction = 1;
    setInterval(() => {
        if (axis === 'x') {
            platform.position.x += speed * direction;
            if (platform.position.x > x + range || platform.position.x < x - range) {
                direction *= -1;
            }
        } else if (axis === 'y') {
            platform.position.y += speed * direction;
            if (platform.position.y > y + range || platform.position.y < y - range) {
                direction *= -1;
            }
        } else if (axis === 'z') {
            platform.position.z += speed * direction;
            if (platform.position.z > z + range || platform.position.z < z - range) {
                direction *= -1;
            }
        }
    }, 30); // update every 30ms
    return platform;
}
// Ground platform (main floor)
createPlatform(0, 0, 0, 30, 1, 20, 0x228B22);


// Usage examples:

// Horizontal moving platform
createMovingPlatform(10, 2, 0, 4, 1, 4, 0x8B4513, 'x', 5, 0.05);

// Vertical moving platform
createMovingPlatform(15, 4, 0, 3, 1, 3, 0x4682B4, 'y', 3, 0.03);

// Goal platform that moves up and down
const goal = createMovingPlatform(26, 11, 0, 3, 1, 4, 0xffff00, 'y', 2, 0.02);





    // Controls
    const keys={};
    document.addEventListener("keydown",e=>keys[e.code]=true);
    document.addEventListener("keyup",e=>keys[e.code]=false);

    // Physics
    let velocityY=0,velocityX=0,velocityZ=0;
    const gravity=-0.01,jumpStrength=0.25,accel=0.02,friction=0.9;
    let onGround=false;

    // Respawn
    let respawnPending=false;
    let cameraFrozen=false;
    let frozenCameraPos=new THREE.Vector3();
    function respawn(){
      player.position.set(0,1,0);
      velocityX=velocityZ=velocityY=0;
      onGround=false;
      cameraFrozen=false;
      document.getElementById("overlay").style.visibility="hidden";
    }

    // Mouse drag rotation
    let isDragging=false,prevX=0,prevY=0,cameraPitch=0;
    document.addEventListener("mousedown",e=>{isDragging=true;prevX=e.clientX;prevY=e.clientY;});
    document.addEventListener("mouseup",()=>{isDragging=false;});
    document.addEventListener("mousemove",e=>{
      if(isDragging){
        const dx=e.clientX-prevX,dy=e.clientY-prevY;
        prevX=e.clientX;prevY=e.clientY;
        player.rotation.y-=dx*0.01;
        cameraPitch+=dy*0.01;
        // Clamp pitch so you can't look under the map
        cameraPitch=Math.max(0,Math.min(1.2,cameraPitch));
      }
    });

    function animate(){
      requestAnimationFrame(animate);

      // Movement
      if(keys["ArrowLeft"]) velocityX-=accel;
      if(keys["ArrowRight"]) velocityX+=accel;
      if(keys["ArrowUp"]) velocityZ-=accel;
      if(keys["ArrowDown"]) velocityZ+=accel;
      velocityX*=friction; velocityZ*=friction;

      const forward=new THREE.Vector3(Math.sin(player.rotation.y),0,Math.cos(player.rotation.y));
      const right=new THREE.Vector3(Math.cos(player.rotation.y),0,-Math.sin(player.rotation.y));
      player.position.addScaledVector(forward,velocityZ);
      player.position.addScaledVector(right,velocityX);

      if(keys["Space"]&&onGround){velocityY=jumpStrength;onGround=false;}
      velocityY+=gravity; player.position.y+=velocityY;

      // Collision with platforms
      let supported=false;
      const half=0.5;
      platforms.forEach(p=>{
        const pm=p.mesh;
        const pMinX=player.position.x-half,pMaxX=player.position.x+half;
        const pMinY=player.position.y-half,pMaxY=player.position.y+half;
        const pMinZ=player.position.z-half,pMaxZ=player.position.z+half;
        const minX=pm.position.x-p.halfW,maxX=pm.position.x+p.halfW;
        const minY=pm.position.y-p.halfH,maxY=pm.position.y+p.halfH;
        const minZ=pm.position.z-p.halfD,maxZ=pm.position.z+p.halfD;
        const overlapX=pMaxX>minX&&pMinX<maxX;
        const overlapY=pMaxY>minY&&pMinY<maxY;
        const overlapZ=pMaxZ>minZ&&pMinZ<maxZ;
        if(overlapX&&overlapY&&overlapZ){
          if(velocityY<=0&&pMinY<maxY&&pMaxY>maxY){
            player.position.y=maxY+half; velocityY=0; supported=true;
            if(pm.material.color.getHex()===0xffff00){
              document.getElementById("overlay").style.visibility="visible";
            }
          }
        }
      });
      onGround=supported;

      // Respawn if fall
      if(player.position.y<-50&&!respawnPending){
        respawnPending=true;
        setTimeout(()=>{respawn();respawnPending=false;},1000);
      }

      // Camera follow
      if(!cameraFrozen){
        const radius=12;
        const offsetX=Math.sin(player.rotation.y)*Math.cos(cameraPitch)*radius;
        const offsetZ=Math.cos(player.rotation.y)*Math.cos(cameraPitch)*radius;
        const offsetY=Math.sin(cameraPitch)*radius;
        camera.position.x=player.position.x+offsetX;
        camera.position.z=player.position.z+offsetZ;
        camera.position.y=player.position.y+offsetY+2;
        if(player.position.y<-10){
          cameraFrozen=true;
          frozenCameraPos.copy(camera.position);
        }
      } else {
        camera.position.copy(frozenCameraPos);
      }

      camera.lookAt(player.position);
      renderer.render(scene,camera);
    }
    animate();

    window.addEventListener("resize",()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    });
  </script>
</body>
</html>

